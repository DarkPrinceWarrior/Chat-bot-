import logging
import os

from AI.lunch import Model
from DB_Models.Roles import Roles
from admin import admin_actions, any_input_handler

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
from AI import lunch
from AI import nltk_utils
import random
import config
import aiogram.utils.markdown as fmt
import numpy as np
from keras.utils.np_utils import to_categorical
from aiogram.types import ParseMode
from telebot import types
from aiogram import *

# You can set parse_mode by default. HTML or MARKDOWN
bot = Bot(config.TOKEN, parse_mode=ParseMode.HTML)

# –î–∏—Å–ø–µ—Ç—á–µ—Ä –¥–ª—è –±–æ—Ç–∞
dp = Dispatcher(bot)
# –í–∫–ª—é—á–∞–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ, —á—Ç–æ–±—ã –Ω–µ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –≤–∞–∂–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
logging.basicConfig(level=logging.INFO)

# create and fit the model
# model = Model()
# model.prepare_train_labels()

@dp.message_handler(commands="start")
async def start_bot(message: types.Message):

    await message.answer("Hello, it's start!")


@dp.message_handler(commands="special_buttons")
async def cmd_special_buttons(message: types.Message):
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.add(types.KeyboardButton(text="–ó–∞–ø—Ä–æ—Å–∏—Ç—å –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é", request_location=True))
    keyboard.add(types.KeyboardButton(text="–ó–∞–ø—Ä–æ—Å–∏—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç", request_contact=True))
    keyboard.add(types.KeyboardButton(text="–°–æ–∑–¥–∞—Ç—å –≤–∏–∫—Ç–æ—Ä–∏–Ω—É",
                                      request_poll=types.KeyboardButtonPollType(type=types.PollType.QUIZ)))
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=keyboard)



# async def any_input_handler(message: types.Message):
#     if message.text == "–ù–∏—á–µ–≥–æ":
#         # reply_markup=types.ReplyKeyboardRemove() —É–¥–∞–ª–∏—Ç—å –∫–ª–∞–≤—É
#         buttons = [
#             types.InlineKeyboardButton(text="–î–ê", callback_data="–î–∞"),
#             types.InlineKeyboardButton(text="–ù–ï–¢", callback_data="–ù–µ—Ç")
#         ]
#         inline_keyboard = types.InlineKeyboardMarkup()
#         inline_keyboard.add(*buttons)
#         await message.answer("–¢–æ—á–Ω–æ?", reply_markup=inline_keyboard)
#     elif message.text == "–ü—Ä—ã–≥–∞—Ç—å":
#         await message.answer("–î–∞–≤–∞–π –Ω–∞—á–Ω–µ–º")
#     else:
#         model1 = model.getModel()
#         sentence = nltk_utils.tokenize(message.text)
#         sentence = nltk_utils.bag_of_words(sentence, model.all_words)
#         sentence = np.array(sentence)
#         sentence = sentence.reshape(1, sentence.shape[0])
#
#         prediction = model1.predict(sentence)
#         tag_index = np.argmax(prediction)
#         tag = model.tags[tag_index]
#         bot_answer = model.getResponse(tag)
#
#
#         mes = "–¢—ã —á–µ—Ç-—Ç–æ —Ç–∞–º –Ω–∞–ø–∏—Å–∞–ª"
#         await message.answer(
#             fmt.text(
#                 fmt.hunderline(mes),
#                 fmt.text(fmt.hbold(bot_answer," :",tag)),
#                 sep="\n"
#
#             ))


@dp.callback_query_handler()
async def send_random_value(call: types.CallbackQuery):
    if call.data == "–î–∞":
        await call.answer(text="–ù—É –∏ —Å–∏–¥–∏ —Å–µ–±–µ!", show_alert=True)
        # –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ await call.answer()
    else:
        await call.answer(text="–û—Ç–ª–∏—á–Ω–æ, —è –∑–Ω–∞–ª, —á—Ç–æ —Ç—ã –Ω–µ —Ç–∞–∫–æ–π, –∫–∞–∫ –≤—Å–µ", show_alert=False)
        # await call.message.answer("–û—Ç–ª–∏—á–Ω–æ, —è –∑–Ω–∞–ª, —á—Ç–æ —Ç—ã –Ω–µ —Ç–∞–∫–æ–π, –∫–∞–∫ –≤—Å–µ")
        # after that Telegram waits for us for 30 sec(wait for callback) and then close the watch icon


# indeed there is fun "answer_dice" in Message
@dp.message_handler(commands="dice")
async def cmd_dice(message: types.Message):
    await message.answer_dice(emoji="üé≤")


@dp.message_handler(content_types=[types.ContentType.ANIMATION])
async def echo_document(message: types.Message):
    await message.reply_animation(message.animation.file_id)


@dp.message_handler(content_types=[types.ContentType.DOCUMENT])
async def download_doc(message: types.Message):
    # –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤ –∫–∞—Ç–∞–ª–æ–≥ —Å –±–æ—Ç–æ–º —Å —Å–æ–∑–¥–∞–Ω–∏–µ–º –ø–æ–¥–∫–∞—Ç–∞–ª–æ–≥–æ–≤ –ø–æ —Ç–∏–ø—É —Ñ–∞–π–ª–∞
    await message.document.download()



dp.register_message_handler(admin_actions, commands="admin")
dp.register_message_handler(any_input_handler)

if __name__ == "__main__":
    executor.start_polling(dp, skip_updates=True)
